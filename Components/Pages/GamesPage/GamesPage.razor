@page "/games"
@rendermode InteractiveServer
@attribute [StreamRendering]

<h3>GamesPage</h3>
@* <div tabindex="0" @onkeydown="HandleKeyDown" style="border: 1px solid black; padding: 20px;">
	Focus this area and press arrow keys.
</div> *@

@for (int i = 0; i < 4; i++)
{
	<div tabindex="0" class="d-flex flex-row" @onkeydown="HandleKeyDown">
		@for (int j = 0; j < 4; j++)
		{
			<div class="card d-flex flex-column justify-content-center align-items-center" style="width: 150px; height:150px; font-size:64px;">
				@matrix[i, j]
			</div>
		}
	</div>
}

@code {
	private int[,] matrix = new int[4, 4];
	private Dictionary<int, (int, int)> zeros = new();

	private Dictionary<string, Func<int, int, (int, int)>> nextPositionMap = new()
	{
		{ "UP", (int row, int col) => (row+1, col) },
		{ "DOWN", (int row, int col) => (row-1, col) },
		{ "LEFT", (int row, int col) => (row, col+1) },
		{ "RIGHT", (int row, int col) => (row, col-1) }
	};

	protected override Task OnInitializedAsync()
	{
		for (var i = 0; i < 4; i++)
		{
			for (var j = 0; j < 4; j++)
			{
				var index = i * 4 + j;
				zeros.Add(index, (i, j));
			}
		}
		InitMatrix();
		return base.OnInitializedAsync();
	}


	private void InitMatrix()
	{
		for (var i = 0; i < 2; i++)
		{
			PopulateTwo();
		}
	}

	private void PopulateTwo()
	{
		var random = new Random(DateTime.UtcNow.Nanosecond);
		var keys = zeros.Keys.ToList();
		if (keys.Count > 0)
		{
			var randomIndex = keys[random.Next(keys.Count)];
			if (zeros.ContainsKey(randomIndex))
			{
				(int row, int col) = zeros[randomIndex];
				zeros.Remove(randomIndex);
				matrix[row, col] = 2;
			}
		}
	}

	private void HandleKeyDown(KeyboardEventArgs e)
	{
		switch (e.Key)
		{
		}
	}

	/// <summary>
	/// returns the next non zero index with value (row, col, value)
	/// </summary>
	/// <param name="row"></param>
	/// <param name="col"></param>
	/// <param name="direction"></param>
	/// <returns></returns>
	private (int, int, int)? NextNonZero(int row, int col, string direction)
	{
		(int nextRow, int nextCol) = nextPositionMap[direction](row, col);
		while(IsInRange(nextRow, nextCol))
		{
			if (matrix[nextRow, nextCol] != 0)
			{
				return (nextRow, nextCol, matrix[nextRow, nextCol]);
			}
			(nextCol, nextCol) = nextPositionMap[direction](nextRow, nextCol);
		}
		return null;
	}

	private bool IsInRange(int row, int col)
	{
		return row >= 0 && row < 4 && col >= 0 && col < 4;
	}
}
